/**
\addtogroup XDispatch

@author Marius Zwicker / MLBA
@date 28.03.2011

@section xd_about Overview

libXDispatch is a C++ API build on top of libdispatch and simplifying the usage by providing
real oo-programming possibilities.

@section xd_blocks Use of Blocks

Similiar to the original libdispatch api we provide blocks within the C++ interface as well.
However as we need to support C++ only (and not C as well), we have more possibilities to support it.
So instead of being limited to use clang 2.0 or Apple's patched gcc version, we can support a range of other
compilers (e.g. MSVC) as well.
 
When Apple introduced Grand Central Dispatch it extended its compilers by a new feature they called "Blocks". Basically this
is lambdas (sometimes called closures as well). They allow an easier way to utilize the libdispatch api and are available when using
Clang or the gcc 4.2 that's shipped with Apple's current Developer Tools.

As we wanted to provide this "Blocks support" on Windows (using Visual Studio or MinGW) and Linux (using GCC) as well, we had to come
up with a way to achieve blocks behaviour without actually patching a compiler. Soon after discovering that Blocks are a bit borked when
used with the patched gcc 4.2 in C++, we had a wonderful idea: As the emerging C++0x standard would indeed have lambda support, all we
had to do was implement support for lambdas when using the libdispatch API in C++.

The result can be found in lambda_blocks.h - Basically we added lambda detection and a macro to map between apples block syntax and the new
lambda syntax. So basically the following lines do all the same:

@code
	xdispatch::global_queue().async(${ printf("Hey Dude"); }); // The $ is available on all platforms
	xdispatch::global_queue().async([=]{ printf("Hey Dude"); }); // The [=] is available on all supported platforms
	xdispatch::global_queue().async(^{ printf("Hey Dude"); }); // The ^ is available on clang / Apple's gcc only.
@endcode 

So whenever you use a compiler featuring C++0x or Blocks you can use the block syntax. If not, you can still
use the functor object interface. To become independent from a specific syntax (may it be [=] or ^), simply
use $ - this can be easily redefined.

As the time of writing, we support the following compilers within our 'cross blocks':
 - Visual Studio 2010
 - GCC 4.5.1+
 - clang 2.0
 - gcc 4.2 (latest apple version)
 
All of our tests passed when using those systems.

@remark Please note that when not using one of those compilers you can still use the entire libXDispatch
		 interface, however the blocks support will be disabled.

@section xd_sync Synchronize Keyword

To simplify the threadsafe programming when using C++ we added the new synchronized { } keyword,
loosely inspired by Java and Objective-C. This is a mechanism much easier to use than a standard
mutex. Please see the documentation generated from xdispatch/synchronized.h for details.

@section xd_use Usage

All header files needed for using libXDispatch can be found at include/xdispatch (symbols are included within
the xdispatch binary). Below you can find a list of all provided classes and functions:

 - xdispatch::queue
 - xdispatch::group
 - xdispatch::semaphore
 - xdispatch::synclock
 - xdispatch::timer
 - xdispatch/base.h
 - synchronize
 - synchronized
   
*/